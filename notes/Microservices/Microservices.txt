
1. Advantages of Microservices vs Monolithic architecture:

 - Development Teams can work on individual services, enabling specialization.
 - Can scale individual services independently, based on demand.
 - Independent service deployment, allowing faster releases.
 - Isolated failures in one service do not affect the entire system.
 - Each service can use the most appropriate technology for its purpose.
 - Easier to set up failover mechanisms for specific services.

========================================================================================================================================================


2. How to handle fault tolerance in a microservice using kafka?

	- Use Replication: Kafka supports data replication for fault tolerance. Configure your Kafka topics to have multiple replicas to ensure data durability. If a Kafka broker or instance fails, another replica can take over, ensuring data availability.
	- Consumer Group: Use Kafka consumer groups for your microservices. If one consumer instance fails, Kafka will automatically rebalance the workload among the remaining consumers in the group. This ensures that no messages are lost.
	- Circuit Breakers and Retries: Implement circuit breakers and retry mechanisms in your microservices. If a service or component experiences temporary issues, retries can help recover from transient failures. Circuit breakers can prevent your system from making repeated requests to a failing service.
	- Backup and Restore: Set up backup and restore processes for Kafka data. Regularly back up your Kafka topics and configurations so that you can recover data in case of catastrophic failures.
	
========================================================================================================================================================
3. Components of microservices:

	- It should have its own server.
	- It should have its own database.
	- It should be fault tolerant.
	- It should have its Service Discovery/Registry.
	- Containerization
	- Orchestration
	- Authentication and Authorization
	- Logging and Monitoring
	- Configuration Management
	
========================================================================================================================================================

4. API Gateway vs Load Balancing vs Service Registry:
	
	- API Gateway:
		- Centralized API Management
		- Routing and Load Balancing
		- Security, rate limiting, and traffic encryption (HTTPS/SSL).
		- Analytics and Monitoring

	- Load Balancing:
		- Scalability: Load balancers can automatically scale the number of server instances based on traffic load, allowing for efficient resource utilization.
		- Optimized Performance: They can route traffic to the closest or least loaded server, optimizing response times and reducing latency.
		- Health Checks: Load balancers can continuously monitor the health of server instances and route traffic only to healthy instances.

	- Service Registry:
		- keep track of available services and their instances, making it easy for services to discover and communicate with each other dynamically.
		- Load Balancing.
		- Resilience: In case of instance failures, service registries can update their information and redirect traffic to healthy instances, improving system resilience.
		- Consistency: Service registries ensure that services always have access to up-to-date information about the available instances, which can be critical in dynamic, containerized environments.
	
========================================================================================================================================================

5. Few important design patterns of microservices:

	- Fault Tolerance: Implement resilience patterns such as retries, timeouts, and fallbacks to handle network and service failures.
	
	- Circuit Breaker:
		- Example: Implement the Circuit Breaker pattern (e.g., with tools like Hystrix) to handle failures gracefully and prevent cascading failures.
	
	- Saga Pattern:
		- The Saga design pattern is a way to manage data consistency across microservices in distributed transaction scenarios.
		- Saga pattern can be achieved using Choreography vs. Orchestration:
			- Choreography - where each service communicates with others through events
			- Orchestration - where a central service manages the flow of activities in a workflow.
	
	- Containerization and Orchestration: Use containerization (e.g., Docker) and container orchestration (e.g., Kubernetes) for managing and deploying microservices.
	
	- Blue-Green Deployments: Use blue-green deployments to minimize downtime during updates by switching traffic from the old version (blue) to the new version (green).
	
========================================================================================================================================================

6. Horizontal Scaling vs Vertical Scaling:

	- Horizontal Scaling (Scaling Out):

		- Horizontal scaling means adding more instances of the same microservice to your application.
		- It's like adding more identical workers to handle a specific job. Each worker can process requests independently.
		- It is cost-effective and often used to handle increased demand by distributing the workload.

	- Vertical Scaling (Scaling Up):

		- Vertical scaling means increasing the capacity of a single microservice instance by adding more resources (like CPU, RAM, or storage) to it.
		- It's like giving a single worker more powerful tools to handle a job. This can make that worker more capable.
		- It can be more expensive and may have limitations based on the hardware.

========================================================================================================================================================

7. 12 Factors of Microservices: codebase, dependencies, dynamic properties, dev-prod parity, auto scaling, logs, admin processes.

	- Codebase & version control: eg: Github/bitbucket
		- Example: Imagine you're building a microservices-based e-commerce platform. Each microservice, like product catalog, shopping cart, and user authentication, should have its own codebase. This separation allows teams to work independently on these services, updating and deploying them without affecting others.
		
	- Dependencies: eg: pom.xml
		- Explicitly declare and isolate dependencies
		
	- Config: eg: cloud config server, cut config. 
		- Example: When deploying a payment processing microservice, you would store API keys, payment gateway URLs, and other configuration settings in environment variables. This allows you to change payment gateway providers without modifying the code.
		
	- Backing service: eg: downstream systems, database, etc..,
		- Example: This principle provides flexibility to change the backing service implementations without major changes to the application. Pluggability can be best achieved by using an abstraction like JPA over an RDBMS data source and using configuration properties (like a JDBC URL) to configure the connection.
		
	- Build, release, run: 
		- Build: we compile the source code and build a Docker image.
		- Release: we tag the image and push it to a registry.
		- Run: we pull the image from the registry and run it as a container instance.
		- Example: A continuous integration/continuous deployment (CI/CD) pipeline should be set up for each microservice. Changes are built, released, and run independently for each service. This ensures that updates are made in a controlled and isolated manner.
		
	- Processes: eg: Autoscaling in AWS.
		- Example: Stateless processes give the application an ability to scale out quickly to handle a sudden increase in traffic and scale in when the traffic to the system decreases.
		
	- Port binding: eg: bind the port using nginx or any gateway.
		- Example: Port Binding refers to an application binding itself to a particular port and listening to all the requests from interested consumers on that port.
		
	- Concurrency - Stateless Applications Help to Scale Out
		- Instead of making a single process even larger, we create multiple processes and then distribute the load of our application among those processes.
		- Example: Traditionally, whenever an application reached the limit of its capacity, the solution was to increase its capacity by adding RAM, CPU, and other resources - a process called vertical scaling. Horizontal scaling or “scaling out”, on the other hand, is a more modern approach, meant to work well with the elastic scalability of cloud environments. Instead of making a single process even larger, we create multiple processes and then distribute the load of our application among those processes.
	
	- Disposability:
		- Example: A chat application's WebSocket service should be designed to start quickly and shut down gracefully. This way, it can be easily restarted or replaced without disrupting the chat service, which is essential for maintaining uptime.
		
	- Dev/Prod Parity - Build Once - Ship Anywhere:
		- The purpose of dev/prod parity is to ensure that the application will work in all environments ideally with no changes.
	
	- Logs:  eg. Sync Logs
		- Example: A log analysis microservice collects log data from various microservices in a streaming fashion and stores them for analysis. This centralized log management helps in troubleshooting issues and monitoring the health of the entire system.
	
	- Admin Processes: eg: Admin UI
		- Example: When scaling a microservice cluster up or down, an administrative process manages the scaling activities. This process is separate from the main application code and is responsible for tasks like launching new instances or updating configurations without affecting user requests.
		
========================================================================================================================================================