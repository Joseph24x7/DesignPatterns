1. Steps to commit the changes to github, when local repo and github repo are not in sync:

	- git init
	- git add .
	- git commit -m "Initial commit"
	- git remote add origin https://github.com/Joseph24x7/SpringBootLearning.github
	- git pull origin main
	- git push origin main
	
========================================================================================================================================================

2. list 10 frequently used Git commands:

	- git init: Initializes a new Git repository in the current directory.
	- git clone: Creates a copy of a remote repository on your local machine.
	- git add: Stages changes for commit. You can specify files or directories to add.
	- git commit: Records changes to the repository with a commit message. Use the -m flag to provide a message inline.
	- git status: Shows the status of your working directory and the files that have been modified or staged.
	- git pull: Fetches changes from a remote repository and merges them into your local branch.
	- git push: Pushes your local commits to a remote repository.
	- git branch: Lists all branches in the repository. Use -a to list remote branches as well.
	- git checkout: Switches to a different branch.
	- git stash: Temporarily saves changes that are not ready to be committed, allowing you to switch branches or apply changes later.
	
========================================================================================================================================================

3. merge vs pull vs rebase vs fetch:

	- Git Merge: Merges the changes from one branch into another, creating a new merge commit to record the merge. Preserves the commit history of both the source and target branches, making it easy to see when and where the merge occurred. 
	- git merge main ( consider am in feature branch )
	
	- git fetch: to retrieve changes from a remote repository, Like new branch created which is not associated with my git repo.
	- git fetch
	
	- Git Pull: Combination of git fetch and git merge.
	- git pull (or) git pull origin main ( consider am in feature branch )

	- Git Rebase: Moves or combines a sequence of commits from one branch on top of another branch, creating a linear commit history. Commonly used when working on feature branches to update them with changes from the main branch.
	- git rebase main ( consider am in feature branch )

========================================================================================================================================================

4. Cherry Pick in Git Commands:

	- It enables you to pick individual commits from one branch and apply them to another branch. 
	- This can be useful in situations where you want to take specific changes from one branch and apply them to another branch without merging the entire branch.
	- git cherry-pick <commit-id> ( Am in main branch and I want to apply a specific commit from feature branch to main branch )

========================================================================================================================================================
5. Mapstruct Library:

	- MapStruct is a Java library used for simplifying object mapping by generating mapping code at compile-time. 
	- It reduces boilerplate code and enhances type safety, making it ideal for converting data between different Java objects. 

========================================================================================================================================================

6. Lombok Library:

	- Project Lombok is a popular Java library that simplifies the development process by reducing the boilerplate code you need to write. 
	- It achieves this by generating code during compilation, which is commonly known as "code generation."
	- @Data, @Builder, @ArgsContructor, @Slf4j, @Value.
	
========================================================================================================================================================

7. use of groupId in kafka?

	- When you use the same groupId for multiple Kafka consumers, Kafka treats them as part of the same consumer group. This allows you to achieve parallelism and load balancing by having each consumer within the group subscribe to and process messages from different partitions of the same topic.
	
	- If they have different groupIds, they will be treated as distinct consumer groups, and Kafka will handle partition assignment, offset management, and other aspects separately for each group. This can lead to multiple consumers independently consuming the same topic.
	
========================================================================================================================================================

8. Queue vs Kafka:

	- Queue - every message is consumed by only one consumer.
	- Kafka - every message can be consumed by multiple consumer groups.
	
	- kafka maintains the order in which messages are stored in partitions
	- queue doesn't guarantee the order in case of any failures.
	
	- once message is ready, it will be cleared from the queue
	- kafka stores the message, by using the offset we can read the messages once again.
	
========================================================================================================================================================

9. Advantages of using partitions in kafka?

	- Partitions allow Kafka to distribute the load and data across multiple brokers and storage servers. 
	- Each partition can be placed on a different server, enabling Kafka to handle more data and clients.
	- Multiple consumers can subscribe to different partitions of a topic, allowing them to process messages concurrently.
	- Kafka's partitioning mechanism helps balance the load across brokers and consumers. 
	- Each partition can have one or more replicas, and each replica is stored on a different broker. If a broker fails, another replica can take over. 

========================================================================================================================================================

10. Advantages of using Redis Cache?

	- High Performance: Redis is an in-memory data store, which means it stores data in RAM.
	- Data Structures: Redis provides a variety of data structures (strings, lists, sets, sorted sets, hashes, and more) that make it versatile for different use cases. 
	- Publish/Subscribe: Redis supports a publish/subscribe messaging system, which allows for real-time communication and broadcasting of data changes.
	- Expiration and TTL: Redis allows you to set a time-to-live (TTL) for cached items. 

========================================================================================================================================================

11. How to handle fault tolerance in a microservice using kafka?

	- Use Replication: Kafka supports data replication for fault tolerance. Configure your Kafka topics to have multiple replicas to ensure data durability. If a Kafka broker or instance fails, another replica can take over, ensuring data availability.
	- Consumer Group: Use Kafka consumer groups for your microservices. If one consumer instance fails, Kafka will automatically rebalance the workload among the remaining consumers in the group. This ensures that no messages are lost.
	- Circuit Breakers and Retries: Implement circuit breakers and retry mechanisms in your microservices. If a service or component experiences temporary issues, retries can help recover from transient failures. Circuit breakers can prevent your system from making repeated requests to a failing service.
	- Backup and Restore: Set up backup and restore processes for Kafka data. Regularly back up your Kafka topics and configurations so that you can recover data in case of catastrophic failures.
	
========================================================================================================================================================