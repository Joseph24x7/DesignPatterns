1. Bean scope - explain each. which is the default bean scope?

- Singleton (default): Spring container creates and manages only one instance of the bean throughout the application's lifecycle.
- Prototype: In Prototype scope, a new instance of the bean is created every time it's requested from the Spring container.
- Request: In Request scope, a new bean instance is created for every HTTP request in a web application.
- Session: In Session scope, a new bean instance is created for each HTTP session in a web application.
- Global Session: It's shared across all users and sessions within the application.

========================================================================================================================================================

2. Can we prototype bean created inside singleton bean?

	- yes possible, but only one instance of prototype bean will be created overall and we lose the behavior of prototype behavior

========================================================================================================================================================

3. bean life cycle:

 - container started
 - bean instantiated ( @component )
 - dependencies injected ( @Autowired )
 - init() method / @postcontruct 
 - actual process 
 - destroy() / @predestroy 

========================================================================================================================================================

4. different ways to inject beans in springboot / spring:

 - Constructor Injection ( @RequiredArgsConstructor )
 - Setter Injection 
 - Field Injection (@Autowired)
 - Method Injection ( @Bean )
 - XML injection

========================================================================================================================================================
5. Constructor Injection vs Field Injection(@Autowired vs @RequiredArgsConstructor):

Immutability: Constructor injection enforces immutability because once the object is constructed, its dependencies cannot be changed. Field injection allows for changes to injected dependencies after the object is created.
Testing: Constructor injection is easier to work with in unit testing because you can create instances with specific dependencies easily. Field injection can be less convenient for testing because you need to rely on reflection or other methods to set dependencies directly on fields.

========================================================================================================================================================

6. BeanFactory(lazy) vs ApplicationContext(eager):

 - Both are used to create beans
 - BF lazy loads the beans whenever it is required,
 - AC is eager loaded.


========================================================================================================================================================

7. 1xx, 2xx, 3xx, 4xx, 5xx - commonly used for?

1xx - Informational
2xx - Success
3xx - Redirect
4xx - Client Error
5xx - Server Error

========================================================================================================================================================

8. PATCH, OPTIONS in http methods usage?

- The PATCH method is used to apply partial modifications to a resource. For example modifying only the status of the employee.
- The OPTIONS method is used to request information about HTTP methods, headers, or other features are supported by a specific resource or server.

========================================================================================================================================================

9. Webclient vs Rest template vs Httpclient vs Rest Client - advantages and disadvantages

 - WebClient -> Synchronous and Asynchronous Communication. It is part of Spring WebFlux.
 - Rest Template -> Only for Synchronous communication
 - Http Client -> Synchronous and Asynchronous Communication. It is part of Java Library.

========================================================================================================================================================

10. Important features and Advantages of Spring boot:

 - Version management by using parent pom
 - Auto configurations
 - Embedded server
 - Easy to integration
 - One of the best Framework provider to implement microservices

========================================================================================================================================================

11. Database connection:

 - how to configure multiple database to be connected at the same time:
	- create multiple data source, session factory, transaction manager using @Bean and @Qualifier in configuration classes
	- In the entity scan we can specify and differentiate what all entities belongs to Data source 1 & Data source 2.

 - how to configure multiple database in which one will be a primary one:
	- by using @Primary annotation
	- If primary bean is not available, it will go for a fallback option for the secondary bean

 - how to use different database per environment:
	- @Profile for environment
	
 - how to use different database on shift basis (like 12am - 12pm one database, 12pm -12am different database):
	- @Conditional for property


========================================================================================================================================================

12. how can we set context-path for our complete project:

 - server.servlet.context-path=/your-context-path

========================================================================================================================================================

13. General dependencies used in your recent project

 - web
 - test
 - actuators
 - devtools
 - jpa
 - webflux
 - redis
 - lombok
 - mapstruct
 - testcontainers

========================================================================================================================================================

14. Annotations specific to Spring boot:

 - @SpringBootApplication
 - @SpringBootTest
 - @ConditionalOnProperty / @ConditionalOnClass
 - @EnableAutoConfiguration
 - @ComponentScan
 - @Profile

========================================================================================================================================================

15. Use of @Profile, @Conditional, @primary:

 - @Profile annotation is used to specify which beans should be loaded based on the active profiles. eg: @Profile("dev") , @Profile("default")
 - @Conditional annotation allows you to conditionally create or exclude beans based on custom conditions. eg: @Conditional(MyCustomCondition.class)
 - @Primary annotation is used to indicate the primary bean to be injected when there are multiple beans of the same type. If primary bean is not available, it will go for a fallback option for the secondary bean

========================================================================================================================================================

16. What is JAR, WAR, EAR:

 - JAR (Java Archive) files can be run as standalone applications, used as libraries, or used in web applications. eg: Lombok is a JAR.
 - WAR (Web Archive) files are used for packaging web applications.
 - EAR (Enterprise Archive) file used for  deploying complex enterprise applications that consist of multiple components such as multiple WARs & JARs.. Mainly used in packaging and deploying monolithic application into Jboss, WildFly Servers..

========================================================================================================================================================

17. Advantages of Microservices vs Monolithic architecture:

 - Development Teams can work on individual services, enabling specialization.
 - Can scale individual services independently, based on demand.
 - Independent service deployment, allowing faster releases.
 - Isolated failures in one service do not affect the entire system.
 - Each service can use the most appropriate technology for its purpose.
 - Easier to set up failover mechanisms for specific services.

========================================================================================================================================================

18. How to write our own Auto Configuring classes and load them:

 - by using @Configuration and optional @Conditional(MyCondition.class). ex: WebConfig.java 
 - @EnableAutoConfiguration(exclude = WebConfig.class)
 
========================================================================================================================================================

19. How can we deploy a war based spring boot application in a traditional way? 

The ServletInitializer class you found in your Spring Boot application is used when you want to deploy your Spring Boot application as a traditional web application (WAR file) in a Servlet container, such as Apache Tomcat or Jboss. By extending SpringBootServletInitializer, you are providing a configuration that allows your Spring Boot application to run as a servlet-based web application.

========================================================================================================================================================

20. CommandLineRunner:

	- Functional interface and has run() method in it.
	- Whatever we define inside this run method will be executed after the Spring Boot application has started.

========================================================================================================================================================

21. What is circualar dependency and how to overcome it?

	- Suppose we have two classes, ClassA and ClassB, and they depend on each other
	- To break the circular dependency, you can introduce an interface or an abstract class and use constructor injection or setter injection to decouple the classes.
	- Now, both ClassA and ClassB depend on the DependencyInterface, which breaks the circular dependency.
	- this is known as dependency inversion principle.

Example:

@Configuration
public class AppConfig {
    @Bean
    public DependencyInterface classA(DependencyInterface classB) {
        return new ClassA(classB);
    }

    @Bean
    public DependencyInterface classB(DependencyInterface classA) {
        return new ClassB(classA);
    }
}

========================================================================================================================================================

19. @Qualifier vs @Resource

	- @Qualifier and @Resource to inject bean by its name.
	- @Qualifier is a Spring-specific annotation used to specify which bean to inject when multiple beans of the same type exist in the Spring application context.
	- @Resource is a standard Java EE annotation that can be used for dependency injection. It is not specific to Spring and can be used in other Java EE environments as well.


========================================================================================================================================================
20. bean by type and bean by name:

	- @Qualifier, @Resource, @Bean(name = "beanByName") to inject bean by its name.
	- @Autowired & @RequiredArgsConstructor, @Bean to inject bean by its type

========================================================================================================================================================

21. 12 Factors of Microservices: codebase, dependencies, dynamic properties, dev-prod parity, auto scaling, logs, admin processes.

	- Codebase & version control: eg: Github/bitbucket
		- Example: Imagine you're building a microservices-based e-commerce platform. Each microservice, like product catalog, shopping cart, and user authentication, should have its own codebase. This separation allows teams to work independently on these services, updating and deploying them without affecting others.
		
	- Dependencies: eg: pom.xml
		- Explicitly declare and isolate dependencies
		
	- Config: eg: cloud config server, cut config. 
		- Example: When deploying a payment processing microservice, you would store API keys, payment gateway URLs, and other configuration settings in environment variables. This allows you to change payment gateway providers without modifying the code.
		
	- Backing service: eg: downstream systems, database, etc..,
		- Example: This principle provides flexibility to change the backing service implementations without major changes to the application. Pluggability can be best achieved by using an abstraction like JPA over an RDBMS data source and using configuration properties (like a JDBC URL) to configure the connection.
		
	- Build, release, run: 
		- Build: we compile the source code and build a Docker image.
		- Release: we tag the image and push it to a registry.
		- Run: we pull the image from the registry and run it as a container instance.
		- Example: A continuous integration/continuous deployment (CI/CD) pipeline should be set up for each microservice. Changes are built, released, and run independently for each service. This ensures that updates are made in a controlled and isolated manner.
		
	- Processes: eg: Autoscaling in AWS.
		- Example: Stateless processes give the application an ability to scale out quickly to handle a sudden increase in traffic and scale in when the traffic to the system decreases.
		
	- Port binding: eg: bind the port using nginx or any gateway.
		- Example: Port Binding refers to an application binding itself to a particular port and listening to all the requests from interested consumers on that port.
		
	- Concurrency - Stateless Applications Help to Scale Out
		- Instead of making a single process even larger, we create multiple processes and then distribute the load of our application among those processes.
		- Example: Traditionally, whenever an application reached the limit of its capacity, the solution was to increase its capacity by adding RAM, CPU, and other resources - a process called vertical scaling. Horizontal scaling or “scaling out”, on the other hand, is a more modern approach, meant to work well with the elastic scalability of cloud environments. Instead of making a single process even larger, we create multiple processes and then distribute the load of our application among those processes.
	
	- Disposability:
		- Example: A chat application's WebSocket service should be designed to start quickly and shut down gracefully. This way, it can be easily restarted or replaced without disrupting the chat service, which is essential for maintaining uptime.
		
	- Dev/Prod Parity - Build Once - Ship Anywhere:
		- The purpose of dev/prod parity is to ensure that the application will work in all environments ideally with no changes.
	
	- Logs:  eg. Sync Logs
		- Example: A log analysis microservice collects log data from various microservices in a streaming fashion and stores them for analysis. This centralized log management helps in troubleshooting issues and monitoring the health of the entire system.
	
	- Admin Processes: eg: Admin UI
		- Example: When scaling a microservice cluster up or down, an administrative process manages the scaling activities. This process is separate from the main application code and is responsible for tasks like launching new instances or updating configurations without affecting user requests.
		
========================================================================================================================================================

22. Horizontal Scaling vs Vertical Scaling:

	- Horizontal Scaling (Scaling Out):

		- Horizontal scaling means adding more instances of the same microservice to your application.
		- It's like adding more identical workers to handle a specific job. Each worker can process requests independently.
		- It is cost-effective and often used to handle increased demand by distributing the workload.

	- Vertical Scaling (Scaling Up):

		- Vertical scaling means increasing the capacity of a single microservice instance by adding more resources (like CPU, RAM, or storage) to it.
		- It's like giving a single worker more powerful tools to handle a job. This can make that worker more capable.
		- It can be more expensive and may have limitations based on the hardware.

========================================================================================================================================================

23. Few important design patterns of microservices:

	- Fault Tolerance: Implement resilience patterns such as retries, timeouts, and fallbacks to handle network and service failures.
	
	- Circuit Breaker:
		- Example: Implement the Circuit Breaker pattern (e.g., with tools like Hystrix) to handle failures gracefully and prevent cascading failures.
	
	- Saga Pattern:
		- The Saga design pattern is a way to manage data consistency across microservices in distributed transaction scenarios.
		
	- Choreography vs. Orchestration:
		- Decide between choreography, where each service communicates with others through events, and orchestration, where a central service manages the flow of activities in a workflow.
	
	- Containerization and Orchestration: Use containerization (e.g., Docker) and container orchestration (e.g., Kubernetes) for managing and deploying microservices.
	
	- Blue-Green Deployments: Use blue-green deployments to minimize downtime during updates by switching traffic from the old version (blue) to the new version (green).
	
========================================================================================================================================================

24. API Gateway vs Load Balancing vs Service Registry:
	
	- API Gateway:
		- Centralized API Management
		- Routing and Load Balancing
		- Security, rate limiting, and traffic encryption (HTTPS/SSL).
		- Analytics and Monitoring

	- Load Balancing:
		- Scalability: Load balancers can automatically scale the number of server instances based on traffic load, allowing for efficient resource utilization.
		- Optimized Performance: They can route traffic to the closest or least loaded server, optimizing response times and reducing latency.
		- Health Checks: Load balancers can continuously monitor the health of server instances and route traffic only to healthy instances.

	- Service Registry:
		- keep track of available services and their instances, making it easy for services to discover and communicate with each other dynamically.
		- Load Balancing.
		- Resilience: In case of instance failures, service registries can update their information and redirect traffic to healthy instances, improving system resilience.
		- Consistency: Service registries ensure that services always have access to up-to-date information about the available instances, which can be critical in dynamic, containerized environments.
	
========================================================================================================================================================

25. how connection pooling works with resttemplate or any client calls?

	- Connection pooling is a technique used in client-server communication to manage and reuse network connections to improve efficiency and performance. 
	-  It does not have built-in support for connection pooling. Instead, it relies on an HTTP client library for its network operations. 
	
	- Code: 
			PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
			connectionManager.setMaxTotal(200); // Maximum total connections
			connectionManager.setDefaultMaxPerRoute(20); // Maximum connections per route

			CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(connectionManager).build();

			// Create a RestTemplate with the custom HttpClient
			RestTemplate restTemplate = new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient));

========================================================================================================================================================

26. how to find the start and end timestamp while making a client call using rest template in spring boot?

	- Create a Custom Aspect: First, create a custom aspect that intercepts RestTemplate client calls and logs the timestamps. You can define this aspect as a Spring @Aspect component.
	@Before("execution(* org.springframework.web.client.RestTemplate.*(..))")
	@AfterReturning("execution(* org.springframework.web.client.RestTemplate.*(..))")
	
	- By using interceptor, while logging request and response.

========================================================================================================================================================
26.  how to create our own custom parser to parse json string to java object?

	- by using reflection api.

========================================================================================================================================================
27. Components of OAuth2/JWT token?

	- For JWT: Seperated by two dots.
		- Headers: {"alg": "HS256", "typ": "JWT"}
		- Payload (Base64-Encoded JSON):{"userDetails": "John Doe", "expiryTimestamp": 1516239022}
		- Signature (Encoded Header + Encoded Payload + Secret Key)

	- OAuth2:
		- Token type
		- Token Expiration
		- Scopes
		- client/User Information
	
========================================================================================================================================================
28. If there are more than one filter chain, how can we ensure the order?

	- by using @Order
	
========================================================================================================================================================
29. Latest features of Spring boot 3.x.x?

	- JDK 17+ and Jakarta EE 9+ Baseline
	- rest template will be deprecated and it will be RestClient
	- Observability
	- Spring Framework 6
	
========================================================================================================================================================

30. 3xx - Redirect - what is the purpose of redirect?

	- @GetMapping("/old-blog-post")
    public String redirectToNewBlogPost() {
        // Perform a temporary redirection (HTTP 302 Found) to the new URL
        return "redirect:/new-blog-post";
    }

    @GetMapping("/new-blog-post")
    public String newBlogPost() {
        // Handle the new blog post page
        return "new_blog_post";
    }
	
	- it is applicable only for get url

========================================================================================================================================================
31. Components of microservices:

	- It should have its own server.
	- It should have its own database.
	- It should be fault tolerant.
	- It should have its Service Discovery/Registry.
	- Containerization
	- Orchestration
	- Authentication and Authorization
	- Logging and Monitoring
	- Configuration Management

========================================================================================================================================================

32. how will you test an private method via junit

	- Reflection API
	- Through public method which is calling that private method.
	
========================================================================================================================================================

33. How to write junit to mock static methods?
	- Inline mockito
	- Powermockito

========================================================================================================================================================

34. Steps to dockerize your application?


	1. creating docker image using docker file:
		FROM openjdk:17-oracle
		EXPOSE 8081
		ADD target/usermanagement.jar usermanagement.jar
		ENTRYPOINT ["java","-jar","/usermanagement.jar"]

	2. In pipeline:
		  - name: Build with Maven
			run: mvn clean install -Dmaven.version=3.9.3
		  - name: Log in to Docker Hub
			run: docker login -u joseph24x7 -p ${{ secrets.DOCKERHUB_TOKEN }}
		  - name: Build Docker image
			run: docker build -t joseph24x7/usermanagement .
		  - name: Push image to Docker Hub
			run: docker push joseph24x7/usermanagement

========================================================================================================================================================

35. How we can create our own hibernate validation annotations

	1.  @Documented
		@Constraint(validatedBy = MyCustomValidator.class)
		@Target({ ElementType.FIELD, ElementType.METHOD })
		@Retention(RetentionPolicy.RUNTIME)
		public @interface MyCustomValidation {
			String message() default "Invalid value";

			Class<?>[] groups() default {};

			Class<? extends Payload>[] payload() default {};
		}


	2.  public class MyCustomValidator implements ConstraintValidator<MyCustomValidation, String> {

			@Override
			public void initialize(MyCustomValidation constraintAnnotation) {
				// Initialization, if needed
			}

			@Override
			public boolean isValid(String value, ConstraintValidatorContext context) {
				// Implement your custom validation logic here
				if (value == null) {
					return true; // Allow null values, or customize as needed
				}
				return value.startsWith("Custom"); // Example validation
			}
		}
		
	3. Set<ConstraintViolation<MyEntity>> violations = validator.validate(myEntity);
	
========================================================================================================================================================