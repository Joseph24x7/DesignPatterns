1. What is multithreading, and how does it differ from multiprocessing?

Multiprocessing:
Multiple independent processes run concurrently on a multi-core or multi-processor system.

Multithreading:
Single process is divided into multiple threads, each of which can execute independently and concurrently.

========================================================================================================================================================

2. What is a race condition in multithreading, and how can it be avoided?

A race condition is a situation that occurs in multithreading when two or more threads access shared data or resources concurrently, and the final outcome depends on the timing or order of execution.  Race conditions can lead to unexpected and undesirable results, including data corruption, program crashes, or incorrect behavior in a multithreaded application.

Example: Withdrawal of money.

========================================================================================================================================================	

3. Ways to create Thread and Advantages in each:

Extending Thread Class (ThreadDemo):
-------------------------------------
- This approach is useful when you need to create a simple, standalone thread. 
- It's often used for tasks that can run independently.

Implementing Runnable Interface (RunnableDemo):
-----------------------------------------------
- This approach is suitable when you want to separate the task logic from the thread management. 
- It's often used when you have multiple tasks that can share the same thread.

Using Lambda Expressions (lambdaThread): 
---------------------------------------
- Same as Java 8

Using CompletableFuture:
-------------------------
- CompletableFuture is used when you need to perform asynchronous tasks that may return results or be composed together. 
- It's often used in scenarios where you want to create a chain of asynchronous operations.
- Suitable for building complex asynchronous workflows.

Using Callable with ExecutorService (callableTask):
--------------------------------------------------
- Callable and ExecutorService are used when you need to execute a task that returns a result or throws an exception. 
- It's often used for tasks that require more control over thread management, resource allocation, and result handling.
- Supports execution of multiple tasks concurrently using a thread pool.

========================================================================================================================================================

4. Synchronous vs Thread Safe:

Synchronous:

- sequential order. Each task must wait for the previous one to complete before it starts.
- In a single-threaded program, operations are inherently synchronous because there is only one thread of execution, and tasks are performed sequentially.

Thread-Safe:

- data structure is designed to be used safely by multiple threads concurrently without causing data corruption or unexpected behavior.
- Thread-safe code ensures that shared resources are accessed and modified in a way that prevents race conditions, data races, and other multithreading-related issues.

========================================================================================================================================================

5. Atomic Integer:

- An AtomicInteger is a part of Java's java.util.concurrent.atomic package

- Thread-Safe Counters: Maintain a counter that multiple threads can increment and decrement concurrently without causing data corruption or race conditions.
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet(); 
counter.decrementAndGet();

- Replacing Synchronization: Instead of using locks or synchronized blocks to protect critical sections of code, you can often use AtomicInteger to achieve the same results with better performance.

========================================================================================================================================================

6. Callable vs Runnable:

Runnable: You typically use Runnable when you want to perform a task in the background without expecting a result or when you want to encapsulate code to run asynchronously.

- It does not return any result directly
- It cannot throw checked exceptions. Any checked exceptions thrown within a Runnable must be caught within the run method.

Callable: You typically use Callable when you need to execute a task concurrently and receive a result or when you want to handle exceptions more flexibly.

- It allows a task to return a value (of a specified type) 
- It allows to throw checked exceptions, which can be captured and handled.

========================================================================================================================================================

7. Volatile vs Atomic Integer:

AtomicInteger:

Purpose: AtomicInteger is primarily used for performing atomic operations on integer variables in a thread-safe manner. 
Atomic Operations: Ensures multiple threads can safely increment, decrement, compare-and-set, or get-and-set values without the need for explicit synchronization.
Use Cases: Use AtomicInteger when you need to perform thread-safe, atomic operations on integer variables, such as maintaining counters,etc.,

Volatile:

Purpose: Its primary purpose is to ensure visibility of changes across threads.
Visibility: volatile guarantees that changes made to the volatile variable by one thread are immediately visible to other threads.
Atomic Operations: Unlike AtomicInteger, volatile does not provide atomic compound operations. It is focused solely on visibility, not atomicity.

In Short, 
Atomicity ensures that an operation is indivisible, preventing concurrent threads from interfering with each other during the operation. It's critical for maintaining data integrity.
Visibility ensures that changes made by one thread are immediately seen by other threads, allowing for effective communication and coordination between threads.


========================================================================================================================================================

8. Wait and sleep methods of threads:

- sleep is a method provided by the Thread class, it makes the current running thread to wait for certain amount of time.
- wait is used when a thread wants to hold its execution until another thread to notify it.
- notify is used to wake up a waiting thread when a certain condition is met or a shared resource is ready.
- join is used to make the current thread wait until another thread completes its execution.

========================================================================================================================================================

9. how deadlock occurs, when thread deadlock will occur and how to solve it:

- Deadlock occurs in a multithreaded program when two or more threads are unable to proceed with their execution because they are each waiting for the other(s) to release a resource or lock.
- This results in a standstill where no thread can make progress, and the program becomes unresponsive. 

types:
- circular deadlock
- resource wait deadlock

========================================================================================================================================================

10. Synchronized block vs synchronized method:

Synchronized Method:

When a method is declared as synchronized, it means that the entire method is synchronized. 
Only one thread can execute the synchronized method at a time, even if there are multiple methods within the same class that are synchronized.

Synchronized Block:

With synchronized blocks, you can specify a specific block of code to be synchronized. 
Multiple threads can execute other non-synchronized code within the same class concurrently, as long as they don't enter the synchronized block simultaneously.

========================================================================================================================================================


Thread pooling concept in parallel streams
What is a thread pool, and why is it useful in multithreaded applications?
Can you explain the concept of thread safety and how it can be achieved in multithreading?
What are mutexes and semaphores, and how are they used in synchronization?
What is deadlock in multithreading, and how can it be prevented or resolved?
How do you handle exceptions in multithreaded programs?
What is the Java Memory Model (JMM), and how does it relate to multithreading?
Explain the terms "synchronized" and "volatile" in the context of Java multithreading.
What is the purpose of the "join" method in Java threads?
Describe the various thread states in a typical thread lifecycle.
How can you prioritize threads in Java, and what is the significance of thread priorities?
Explain the concept of thread-local storage (TLS) and its use cases.
What are thread-safe data structures, and why are they important in multithreaded programming?
Discuss the benefits and drawbacks of using locks versus lock-free synchronization techniques.
What is the "fork-join" framework in Java, and when is it appropriate to use it?
Can you describe some common pitfalls and best practices for multithreaded programming?