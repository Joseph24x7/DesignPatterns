Java:

1) Abstract Class vs Interface. when to use abstract class and when to use interface:

Method Declaration:
AC: Can have abstract (unimplemented) and concrete (implemented) methods.	
IF: Can have only abstract (unimplemented) methods by default. Can have default and static methods in Java 8+.

Fields:
AC: Can have instance variables (fields).	
IF: Cannot have instance variables (fields). Has only constants.

Constructors:
AC: Can have constructors to instantiate instance variables.
IF: Cannot have constructors.

Access Modifiers:
AC: Methods and fields can have various access modifiers
IF: Methods are implicitly public. Fields are implicitly public, static, and final

Multiple Inheritance:
AC: Inherited class can extend only one abstract class.	
IF: A class can implement multiple interfaces.

Instantiation:
AC:	Cannot be instantiated directly.
IF:	Cannot be instantiated directly.

------------------------------------------------------------------------------------------------------------------------------------------------------

2) Explain 00PS concepts with real time example:

Abstraction: An ATM machine is an abstraction. Users interact with a simple interface (e.g., withdraw, deposit), while the inner workings (banking processes, security measures) are abstracted away. Users don't need to know the complex operations happening behind the scenes.

Encapsulation: An ATM machine is an Encapsulation. Where we hide the encapsulate and hide the user information from each others.

Inheritance: In a real-time example, consider the "Customer" class as a superclass. Personal Customer and Business Customer.

Polymorphism: Account Verification process for Business and Personal Customer.

------------------------------------------------------------------------------------------------------------------------------------------------------

3) can we overload/override the static/final?

static can be overloaded, cannot be overriden.
final can be overloaded, cannot be overloaded.

is it possible to overload a main method? yes

------------------------------------------------------------------------------------------------------------------------------------------------------

4) method overiding with different return type: only same or covariant type is allowed.
   method overiding with different access specifier: we cannot reduce visibility. (public, protected, default, and private)
   method overiding with different exception type: Broader exceptions are not allowed, narrowiing/no exception/same exception is allowed.

------------------------------------------------------------------------------------------------------------------------------------------------------

5. Predefined final classes in Java. give some examples.

- java.lang.String
- java.lang.Math
- java.lang.System
- java.util.UUID
- java.lang.Character / Integer / ....

------------------------------------------------------------------------------------------------------------------------------------------------------

6. Why String is immutable? Advantages of being immutable 

Reasons for Immutability:

Security: Strings are often used to store sensitive information, such as passwords. Immutability ensures that once a string is created, its value cannot be modified, reducing the risk of data tampering.
Thread Safety: In a multi-threaded environment, multiple threads can safely read and share immutable strings without the need for additional synchronization.
Caching: Because strings are immutable, Java can optimize memory usage by reusing string instances. 
Hashing: Immutable strings can be used as keys in hash tables (e.g., HashMap) because their hash code remains constant. 

Advantages of Immutability:

Safety: Immutability guarantees that the value of a string remains constant, reducing the risk of unintended modification.
Thread Safety: Immutable strings can be shared among multiple threads without synchronization concerns, leading to more efficient and reliable multi-threaded code.
Performance: String interning and caching can lead to better memory utilization and reduced overhead when working with strings.
Hashing and Collections: Immutability enables the use of strings as keys in hash-based collections, such as hash maps, because their hash code remains consistent.

------------------------------------------------------------------------------------------------------------------------------------------------------

7. What if we don't add Serializable interface to the class which undergoes platform interchange? 

The Java runtime will throw a NotSerializableException. This exception occurs because the Java serialization mechanism relies on the Serializable interface to determine whether an object can be serialized safely.

What is serialVersion UID? What if we do not define that when we implement Serializable interface. ?

The serialVersionUID (serial version UID) is a unique identifier associated with a serialized class in Java. It serves as a version control mechanism for serialized objects. When a class implements the Serializable interface, a serialVersionUID field can be optionally defined.  If you do not provide a serialVersionUID, Java will automatically generate one for your class during compilation.

Versioning Challenges & Compatibility Issues: The generated serialVersionUID may not be consistent across different versions of your class. When you attempt to deserialize an object that was serialized with an older or newer version of the class, a version mismatch can occur, leading to a InvalidClassException at runtime.

------------------------------------------------------------------------------------------------------------------------------------------------------
8. What is Java Reflection API?

Allows us to inspect and manipulate the structure and behavior of the Java classes, interfaces, methods, fields, and other class members at runtime. 

------------------------------------------------------------------------------------------------------------------------------------------------------

9. Class loaders:

In Java, a class loader is a fundamental component of the Java Virtual Machine (JVM) responsible for loading class files into memory so that they can be executed by the JVM. 
We can have our own custom class loader as well.

Here are some common types of class loaders along with examples:
Bootstrap Class Loader:
The Bootstrap Class Loader is the parent of all class loaders and is responsible for loading core Java classes, such as those from the java.lang package.
It is implemented in native code and is not typically programmatically accessible.

------------------------------------------------------------------------------------------------------------------------------------------------------

10. Generics in java. advantages of using generics? 

helps us to operate on type parameters, allowing you to write code that is more flexible, type-safe, and reusable. 

Advantages:
Type Safety & Reduced Casting: Generics help catch type-related errors at compile time rather than at runtime. This prevents class cast exceptions and enhances code reliability.
Code Reusability: Generics allow you to write reusable code that works with different data types without code duplication. A single generic class or method can operate on various types.

------------------------------------------------------------------------------------------------------------------------------------------------------

11. Name few spring based exceptions faced in real time project and how did you overcome it.

- BeanCreationException / NoSuchBeanDefinitionException
- AccessDeniedException / AuthenticationException
- ConstraintViolationException / MethodArgumentNotValidException

------------------------------------------------------------------------------------------------------------------------------------------------------

12. Steps to overcome outofmemoryerror:

- Optimize Code and Data Structures
- Avoid Memory Leaks by using something like try-with-resources 
- Load Testing and Scaling
- Increase Heap Size / Increase the number of Instance

------------------------------------------------------------------------------------------------------------------------------------------------------

13. Synchronized Map vs Concurrent Map:

Synchronized Map:

Synchronization & Blocking:  When one thread is performing an operation on the map, other threads must wait until it's done.
Performance: Synchronized maps can suffer from performance bottlenecks in highly concurrent scenarios because they serialize access to the map. This can limit scalability and throughput.

Concurrent Map:

Concurrent Operations & Non-Blocking: Concurrent maps do not block threads during read or write operations. Multiple threads can read and write concurrently without waiting for each other.
Performance: Concurrent maps are designed for high-concurrency scenarios and can offer better performance in situations where many threads need to access and modify the map simultaneously.

------------------------------------------------------------------------------------------------------------------------------------------------------

14. Conurrent Hashmap:

A ConcurrentHashMap is like a special librarian who knows how to let kids pick books without bumping into each other. It uses invisible lines and special rules so that everyone can get their books safely and without waiting too long.

- The ConcurrentHashMap is divided into multiple segments, each of which is essentially a separate hash table. 
- When a thread wants to modify a segment, it acquires the lock for that segment, ensuring that other threads cannot concurrently modify the same segment. 
- Can offer better performance in situations where many threads need to access and modify the map simultaneously.

------------------------------------------------------------------------------------------------------------------------------------------------------

15. HashMap vs Concurrent HashMap:

- HashMap is a single hash table.
- HashMap doesn't provide built-in thread safety. Multiple threads can lead to data corruption without external synchronization.
- HashMap has better performance compared to ConcurrentHashMap

- ConcurrentHashMap is divided into multiple segments, each acting as a separate hash table.
- When a thread wants to modify a segment, it locks only that segment, allowing other threads to operate concurrently on different segments.


------------------------------------------------------------------------------------------------------------------------------------------------------

16. Features of Java 9 and Above:

Latest stable version is Java 21.

Java 9 - 

Immutable Collection. List.of(), Set.of(), Map.of()
UnsupportedOperationException - will be thrown when we modify it.
NullPointerException - when we add null elements.

Java 10 - 

Immutable Collection. List.copyOf(list); - creates a immutable collection from a mutable collection.
UnsupportedOperationException - will be thrown when we modify it.
NullPointerException - when we add null elements.

Local-Variable Type Inference (var):
var list = new ArrayList<String>();

Java 12 -

Switch Expressions: Use switch as an expression rather than a statement, making code more concise.

Java 13 -

Text Blocks: Text blocks will simplify the part of writing multiline strings.

Java 14 -

Records (Preview Feature): 
- Concise way to declare classes that are mainly used for data storage.
- They automatically generate methods like constructors, equals(), hashCode(), and toString().
- Records ensure that the data they encapsulate is immutable, meaning once created, their values cannot be changed. 

Pattern Matching for instanceof (Preview Feature): Pattern matching for instanceof simplifies code for type checking and casting.


Java 15 -

Sealed classes:
- Allows you to control which classes can extend or implement them. 
- This feature helps enhance code security and maintainability by restricting the hierarchy of related classes.

------------------------------------------------------------------------------------------------------------------------------------------------------

17. @Value vs record:

@Value (from Project Lombok):
 - @Value is not part of the standard Java language; it's a feature provided by Project Lombok, a third-party library. 
 - @Value is used to generate immutable classes with getters, equals, hashCode, and toString methods without writing the boilerplate code yourself.
 - You can customize the generated methods by using additional Lombok annotations.
 
record (Java language feature):
 - You don't need any third-party libraries or dependencies; it's part of the Java language itself.
 - It automatically generates constructors, equals(), hashCode(), and toString() methods based on the components (fields) you define in the record.
 - While you can't customize the generated methods, you can add your methods, constants, or interfaces to a record.
 
------------------------------------------------------------------------------------------------------------------------------------------------------

18. final vs non-sealed vs sealed class

Sealed classes:
- Allows you to control which classes can extend or implement them. 
- This feature helps enhance code security and maintainability by restricting the hierarchy of related classes.

final Class:
- A final class is the most restrictive in terms of inheritance. It cannot be extended; you cannot create subclasses of a final class.

non-sealed Class:
- A non-sealed class allows you to create subclasses, but it does not impose any restrictions on who can create subclasses or where they can be located in the codebase.

------------------------------------------------------------------------------------------------------------------------------------------------------

19. Use of optional:

- used to do null check in a more structured way.
- It is always a good practise to bound the response with Optional.of() when method may return null. In case of null we can go ahead with Optional.empty().

------------------------------------------------------------------------------------------------------------------------------------------------------

20. intermediate vs terminal? Is intermediate eager or lazy loaded? Is terminal eager or lazy loaded?

Intermediate Operations:

- filter(), map(), flatMap(), sorted()
- lazy-loaded, it requires terminal operations to be executed.

Terminal Operations:

- forEach(), collect(), min(), max(), count()
- eager loaded, it is applied over intermediate to produce a result.

------------------------------------------------------------------------------------------------------------------------------------------------------

21. @Valid vs @Validated:

@Valid: used for bean validations and part of jakarta.validation library.
@Validated: is part of the Spring Framework and is used for method-level validation 

Example:
@Service
@Validated
public class MyService {
    public void process(@NotBlank String data) {
        // ...
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------

22. Examples of some predefined functional interfaces:

	Consumer<T>: (used in list.foreach())
	 - Represents an operation that takes an input argument of type T and returns no result.
	 - Example: Consumer<String> printUpperCase = str -> System.out.println(str.toUpperCase());

	Supplier<T>: (used in orElseGet() which is part of optional)
	 - It does not take any input but produces a result of type T.
	 - Example: Supplier<Integer> getRandomNumber = () -> new Random().nextInt();

	Function<T, R>: (used in stream().map())
	 - Represents a function that takes an input of type T and produces a result of type R.
	 - Example: Function<String, Integer> strLength = str -> str.length();
	 
	Predicate<T>: ((used in stream().filter())
	 - Represents a predicate (boolean-valued function) that takes an input of type T.
	 - Example: Predicate<Integer> isEven = num -> num % 2 == 0;
	 
------------------------------------------------------------------------------------------------------------------------------------------------------