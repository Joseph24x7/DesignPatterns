1. Steps to commit the changes to github, when local repo and github repo are not in sync:

	- git init
	- git add .
	- git commit -m "Initial commit"
	- git remote add origin https://github.com/Joseph24x7/SpringBootLearning.github
	- git pull origin main
	- git push origin main
	
========================================================================================================================================================

2. list 10 frequently used Git commands:

	- git init: Initializes a new Git repository in the current directory.
	- git clone: Creates a copy of a remote repository on your local machine.
	- git add: Stages changes for commit. You can specify files or directories to add.
	- git commit: Records changes to the repository with a commit message. Use the -m flag to provide a message inline.
	- git status: Shows the status of your working directory and the files that have been modified or staged.
	- git pull: Fetches changes from a remote repository and merges them into your local branch.
	- git push: Pushes your local commits to a remote repository.
	- git branch: Lists all branches in the repository. Use -a to list remote branches as well.
	- git checkout: Switches to a different branch.
	- git stash: Temporarily saves changes that are not ready to be committed, allowing you to switch branches or apply changes later.
	
========================================================================================================================================================

3. merge vs pull vs rebase vs fetch:

	- Git Merge: Merges the changes from one branch into another, creating a new merge commit to record the merge. Preserves the commit history of both the source and target branches, making it easy to see when and where the merge occurred. 
	- git merge main ( consider am in feature branch )
	
	- git fetch: to retrieve changes from a remote repository, Like new branch created which is not associated with my git repo.
	- git fetch
	
	- Git Pull: Combination of git fetch and git merge.
	- git pull (or) git pull origin main ( consider am in feature branch )

	- Git Rebase: Moves or combines a sequence of commits from one branch on top of another branch, creating a linear commit history. Commonly used when working on feature branches to update them with changes from the main branch.
	- git rebase main ( consider am in feature branch )

========================================================================================================================================================

4. Cherry Pick in Git Commands:

	- It enables you to pick individual commits from one branch and apply them to another branch. 
	- This can be useful in situations where you want to take specific changes from one branch and apply them to another branch without merging the entire branch.
	- git cherry-pick <commit-id> ( Am in main branch and I want to apply a specific commit from feature branch to main branch )

========================================================================================================================================================
5. Mapstruct Library:

	- MapStruct is a Java library used for simplifying object mapping by generating mapping code at compile-time. 
	- It reduces boilerplate code and enhances type safety, making it ideal for converting data between different Java objects. 

========================================================================================================================================================

6. Lombok Library:

	- Project Lombok is a popular Java library that simplifies the development process by reducing the boilerplate code you need to write. 
	- It achieves this by generating code during compilation, which is commonly known as "code generation."
	- @Data, @Builder, @ArgsContructor, @Slf4j, @Value.
	
========================================================================================================================================================

7. use of groupId in kafka?

	- When you use the same groupId for multiple Kafka consumers, Kafka treats them as part of the same consumer group. This allows you to achieve parallelism and load balancing by having each consumer within the group subscribe to and process messages from different partitions of the same topic.
	
	- If they have different groupIds, they will be treated as distinct consumer groups, and Kafka will handle partition assignment, offset management, and other aspects separately for each group. This can lead to multiple consumers independently consuming the same topic.
	
========================================================================================================================================================

8. Queue vs Kafka:

	- Queue - every message is consumed by only one consumer.
	- Kafka - every message can be consumed by multiple consumer groups.
	
	- kafka maintains the order in which messages are stored in partitions
	- queue doesn't guarantee the order in case of any failures.
	
	- once message is ready, it will be cleared from the queue
	- kafka stores the message, by using the offset we can read the messages once again.
	
========================================================================================================================================================

9. Advantages of using Queue?
